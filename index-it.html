
<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Il Codice dei Bias Cognitivi</title>
    <link rel="stylesheet" href="assets/css/style.css" />
    <!-- Tippy.js for tooltips -->
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/tippy.js@6/themes/light.css"
    />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/manifest.json" />

    <!-- Primary Meta Tags -->
    <meta name="title" content="Il Codice dei Bias Cognitivi" />
    <meta
      name="description"
      content="Una visualizzazione interattiva dei bias cognitivi che influenzano il pensiero umano e il processo decisionale"
    />
    <meta
      name="keywords"
      content="bias cognitivi, psicologia, processo decisionale, pensiero critico, fallacie logiche"
    />
    <meta name="author" content="Contributori di Bias Wiki" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://bias.wiki/" />
    <meta property="og:title" content="Il Codice dei Bias Cognitivi" />
    <meta
      property="og:description"
      content="Esplora la visualizzazione interattiva dei bias cognitivi che influenzano il pensiero umano e il processo decisionale"
    />
    <meta property="og:image" content="/assets/images/og.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://bias.wiki/" />
    <meta property="twitter:title" content="Il Codice dei Bias Cognitivi" />
    <meta
      property="twitter:description"
      content="Esplora la visualizzazione interattiva dei bias cognitivi"
    />
    <meta property="twitter:image" content="/assets/images/og.png" />

    <!-- Additional meta tags -->
    <meta name="robots" content="index, follow" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="msapplication-TileColor" content="#0066cc" />
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Bias.Wiki" />
    <meta name="theme-color" content="#0066cc" />
  </head>
  <body>
    <div id="container">
      <div id="svg-container">
        <!-- Italian SVG will be loaded here -->
      </div>
    </div>

    <div class="info-button">i</div>
    <div class="info-panel">
      <div class="info-panel-content">
        <span class="close-info">&times;</span>
        <h2>Il Codice dei Bias Cognitivi</h2>
        <p>
          Una rappresentazione visiva dei bias cognitivi che influenzano il pensiero umano
          e il processo decisionale.
        </p>
        <p>Clicca o tocca sui singoli bias per saperne di più.</p>
        <div class="credits">
          <p>
            Codice Sorgente:
            <a href="https://github.com/kocijan/bias-wiki" target="_blank"
              >Disponibile su GitHub</a
            >
          </p>
          <p>Contributi e feedback sono benvenuti tramite GitHub</p>
          <p>
            Il Codice dei Bias Cognitivi è concesso in licenza
            <a
              href="https://creativecommons.org/licenses/by-sa/4.0/"
              target="_blank"
              >CC BY-SA 4.0</a
            >
          </p>
          <p>
            Lavoro originale di
            <a
              href="https://betterhumans.pub/cognitive-bias-cheat-sheet-55a472476b18"
              target="_blank"
              >Buster Benson</a
            >
            e
            <a
              href="https://www.visualcapitalist.com/wp-content/uploads/2017/09/cognitive-bias-infographic.html"
              target="_blank"
              >John Manoogian III</a
            >. Sito web interattivo di <a
              href="https://github.com/kocijan"
              target="_blank"
              >Martin Josip Kocijan</a
            >
          </p>
        </div>
      </div>
    </div>

    <script>
      // Italian-only version with pan/zoom functionality
      let currentZoomState = {
        x: 0,
        y: 0,
        width: 1900,
        height: 1500,
      };
      let initialPinchMidpoint = { x: 0, y: 0 };
      let lastPinchMidpoint = { x: 0, y: 0 };

      document.addEventListener('DOMContentLoaded', function() {
        const infoButton = document.querySelector('.info-button');
        const infoPanel = document.querySelector('.info-panel');
        const closeInfo = document.querySelector('.close-info');

        // Info panel functionality
        infoButton.addEventListener('click', function() {
          infoPanel.classList.toggle('show');
        });

        closeInfo.addEventListener('click', function() {
          infoPanel.classList.remove('show');
        });

        // Close info panel when clicking outside
        document.addEventListener('click', function(event) {
          if (!infoPanel.contains(event.target) && event.target !== infoButton) {
            infoPanel.classList.remove('show');
          }
        });

        // Load Italian SVG directly and initialize pan/zoom
        const svgContainer = document.getElementById('svg-container');
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'loading-indicator';
        loadingIndicator.innerHTML = '<div class="spinner"></div><p>Caricamento del Codice dei Bias Cognitivi...</p>';
        svgContainer.appendChild(loadingIndicator);

        fetch('assets/images/cognitive_bias_codex_it_ONLY.svg')
          .then(response => response.text())
          .then(svgContent => {
            // Remove loading indicator
            svgContainer.removeChild(loadingIndicator);
            
            // Insert SVG content directly
            svgContainer.innerHTML = svgContent;
            
            const svg = svgContainer.querySelector('svg');
            if (svg) {
              svg.setAttribute('viewBox', '0 0 1900 1500');
              initializePanZoom(svg);
              initializeTooltips();
            }
          })
          .catch(error => {
            console.error('Error loading Italian SVG:', error);
            loadingIndicator.innerHTML = `<div class="error">Errore nel caricamento del contenuto: ${error.message}</div><p>Per favore, prova a ricaricare la pagina.</p>`;
          });
      });

      // Pan/Zoom functionality
      function initializePanZoom(svg) {
        const svgContainer = document.getElementById('svg-container');
        
        // Apply direct touch-action control to the SVG element
        svg.style.touchAction = 'none';

        // Variables for pan functionality
        let isPanning = false;
        let startPoint = { x: 0, y: 0 };
        let viewBox = { x: 0, y: 0, width: 1900, height: 1500 };

        // Variables for pinch zoom
        let initialDistance = 0;
        let initialScale = 1;
        let isPinching = false;

        // Add these variables for touch handling
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };
        let isDragging = false;
        const TAP_THRESHOLD = 10; // pixels
        const TAP_TIME_THRESHOLD = 300; // milliseconds

        // Initialize viewBox from SVG
        const initialViewBox = svg.getAttribute('viewBox');
        if (initialViewBox) {
          const parts = initialViewBox.split(' ');
          viewBox = {
            x: parseFloat(parts[0]),
            y: parseFloat(parts[1]),
            width: parseFloat(parts[2]),
            height: parseFloat(parts[3]),
          };
          currentZoomState = { ...viewBox }; // Store initial state
        }

        // Pan functions
        function startPan(e) {
          if (e.touches && e.touches.length === 2) {
            // This is a pinch gesture
            isPinching = true;
            isPanning = false;

            // Calculate initial distance between two fingers
            initialDistance = getDistance(
              e.touches[0].clientX,
              e.touches[0].clientY,
              e.touches[1].clientX,
              e.touches[1].clientY
            );

            // Store the current scale
            initialScale = currentZoomState.width / 1900; // 1900 is base width

            // Store initial midpoint for pan tracking
            initialPinchMidpoint = {
              x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
              y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
            };

            // Store previous midpoint (will update during move)
            lastPinchMidpoint = { ...initialPinchMidpoint };

            // Start from current zoom state
            viewBox = { ...currentZoomState };

            return;
          }

          // Record the starting time and position
          touchStartTime = Date.now();
          const event = e.type.startsWith('touch') ? e.touches[0] : e;
          touchStartPos = { x: event.clientX, y: event.clientY };
          isDragging = false;

          // Single touch = pan
          isPanning = true;
          isPinching = false;
          startPoint = { x: event.clientX, y: event.clientY };

          // Start from current zoom state instead of default
          viewBox = { ...currentZoomState };
        }

        function movePan(e) {
          if (isPinching && e.touches && e.touches.length === 2) {
            // COMBINED PINCH-ZOOM AND PAN
            const rect = svgContainer.getBoundingClientRect();

            // 1. CALCULATE ZOOM COMPONENT
            const currentDistance = getDistance(
              e.touches[0].clientX,
              e.touches[0].clientY,
              e.touches[1].clientX,
              e.touches[1].clientY
            );

            // Scale factor calculation
            const scaleFactor = initialDistance / currentDistance;

            // 2. CALCULATE PAN COMPONENT
            // Current midpoint between fingers
            const currentMidpoint = {
              x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
              y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
            };

            // Calculate how much the midpoint moved since last event
            const midpointDeltaX = currentMidpoint.x - lastPinchMidpoint.x;
            const midpointDeltaY = currentMidpoint.y - lastPinchMidpoint.y;

            // 3. APPLY BOTH TRANSFORMATIONS

            // Calculate new scale with limits
            const newScale = initialScale * scaleFactor;
            const limitedScale = Math.min(Math.max(newScale, 0.04), 1);

            // New dimensions based on scale
            const newWidth = 1900 * limitedScale;
            const newHeight = 1500 * limitedScale;

            // First calculate new position based on the zoom alone
            const svgCenterX =
              ((initialPinchMidpoint.x - rect.left) / rect.width) * viewBox.width +
              viewBox.x;
            const svgCenterY =
              ((initialPinchMidpoint.y - rect.top) / rect.height) * viewBox.height +
              viewBox.y;

            const verticalMultiplier = 2.5;

            let newX =
              svgCenterX -
              ((initialPinchMidpoint.x - rect.left) / rect.width) * newWidth;
            let newY =
              svgCenterY -
              ((initialPinchMidpoint.y - rect.top) / rect.height) * newHeight;

            // Then add the pan offset
            newX -= (midpointDeltaX * newWidth) / rect.width;
            newY -= ((midpointDeltaY * newHeight) / rect.height) * verticalMultiplier;

            // Update viewBox with combined zoom and pan
            viewBox = {
              x: newX,
              y: newY,
              width: newWidth,
              height: newHeight,
            };

            // Store current midpoint for next incremental pan calculation
            lastPinchMidpoint = currentMidpoint;

            updateViewBox();
            return;
          }

          if (!isPanning) return;

          const event = e.type.startsWith('touch') ? e.touches[0] : e;
          const dx = event.clientX - touchStartPos.x;
          const dy = event.clientY - touchStartPos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // If moved enough, consider it a drag
          if (distance > TAP_THRESHOLD) {
            isDragging = true;

            // Now we can safely prevent default to enable panning
            if (e.type.startsWith('touch')) {
              e.preventDefault();
            }

            const verticalMultiplier = 1.5;

            const dx =
              ((event.clientX - startPoint.x) * viewBox.width) /
              svgContainer.clientWidth;
            const dy =
              (((event.clientY - startPoint.y) * viewBox.height) /
                svgContainer.clientHeight) *
              verticalMultiplier;
            viewBox.x -= dx;
            viewBox.y -= dy;
            startPoint = { x: event.clientX, y: event.clientY };
            updateViewBox();
          }
        }

        function endPan(e) {
          // Reset state
          isPanning = false;
          isPinching = false;
          isDragging = false;
        }

        // Helper function to calculate distance between two points
        function getDistance(x1, y1, x2, y2) {
          return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function updateViewBox() {
          svg.setAttribute(
            'viewBox',
            `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`
          );
          currentZoomState = { ...viewBox }; // Store current state
        }

        // Zoom function
        function handleZoom(e) {
          e.preventDefault();

          const delta = e.deltaY;
          const zoomFactor = delta > 0 ? 1.1 : 0.9;

          // Calculate zoom point in SVG coordinates
          const rect = svgContainer.getBoundingClientRect();
          const mouseX =
            ((e.clientX - rect.left) / rect.width) * viewBox.width + viewBox.x;
          const mouseY =
            ((e.clientY - rect.top) / rect.height) * viewBox.height + viewBox.y;

          // Calculate new dimensions
          const newWidth = viewBox.width * zoomFactor;
          const newHeight = viewBox.height * zoomFactor;

          viewBox.x = mouseX - ((mouseX - viewBox.x) / viewBox.width) * newWidth;
          viewBox.y = mouseY - ((mouseY - viewBox.y) / viewBox.height) * newHeight;
          viewBox.width = newWidth;
          viewBox.height = newHeight;

          updateViewBox();
        }

        // Add event listeners
        if (!isMobileDevice()) {
          // Desktop events
          svg.addEventListener('mousedown', startPan);
          window.addEventListener('mousemove', movePan);
          window.addEventListener('mouseup', endPan);
          svg.addEventListener('wheel', handleZoom);
        } else {
          // Mobile events with pinch zoom support
          svg.addEventListener('touchstart', startPan, { passive: true });
          window.addEventListener('touchmove', movePan, { passive: false });
          window.addEventListener('touchend', endPan);

          // Add zoom controls for mobile
          addZoomControls(svg);
        }
      }

      function isMobileDevice() {
        return (
          window.innerWidth <= 768 ||
          navigator.maxTouchPoints > 0 ||
          navigator.msMaxTouchPoints > 0
        );
      }

      function addZoomControls(svg) {
        // Remove any existing zoom controls first
        const existingControls = document.querySelector('.zoom-controls');
        if (existingControls) {
          document.body.removeChild(existingControls);
        }

        const zoomControls = document.createElement('div');
        zoomControls.className = 'zoom-controls';
        zoomControls.innerHTML = `
              <button class="zoom-in">+</button>
              <button class="zoom-reset">⟳</button>
              <button class="zoom-out">-</button>
          `;

        document.body.appendChild(zoomControls);

        document.querySelector('.zoom-in').addEventListener('click', () => {
          const newWidth = currentZoomState.width * 0.8;
          const newHeight = currentZoomState.height * 0.8;
          const newX = currentZoomState.x + (currentZoomState.width - newWidth) / 2;
          const newY = currentZoomState.y + (currentZoomState.height - newHeight) / 2;

          // Update both DOM and state
          svg.setAttribute('viewBox', `${newX} ${newY} ${newWidth} ${newHeight}`);
          currentZoomState = { x: newX, y: newY, width: newWidth, height: newHeight };
        });

        document.querySelector('.zoom-out').addEventListener('click', () => {
          const newWidth = currentZoomState.width * 1.2;
          const newHeight = currentZoomState.height * 1.2;
          const newX = currentZoomState.x - (newWidth - currentZoomState.width) / 2;
          const newY = currentZoomState.y - (newHeight - currentZoomState.height) / 2;

          // Update both DOM and state
          svg.setAttribute('viewBox', `${newX} ${newY} ${newWidth} ${newHeight}`);
          currentZoomState = { x: newX, y: newY, width: newWidth, height: newHeight };
        });

        document.querySelector('.zoom-reset').addEventListener('click', () => {
          svg.setAttribute('viewBox', '0 0 1900 1500');
          currentZoomState = {
            x: 0,
            y: 0,
            width: 1900,
            height: 1500,
          };
        });
      }

      // Tooltip functionality for Italian version
      function initializeTooltips() {
        const svg = document.querySelector('#svg-container svg');
        if (!svg) return;

        // Get all bias elements (links in the SVG)
        const biasElements = svg.querySelectorAll('a');
        
        // Create tooltip element
        const tooltip = document.createElement('div');
        tooltip.className = 'custom-tooltip';
        tooltip.setAttribute('role', 'tooltip');
        tooltip.innerHTML = '<div class="tooltip-arrow" data-popper-arrow></div>';
        document.body.appendChild(tooltip);

        // Variables to track state
        let currentPopperInstance = null;
        let currentElement = null;
        let hideTimeoutId = null;
        let isTooltipLocked = false;
        let italianBiasData = null;

        // Load Italian bias data
        fetch('biases_wikipedia_it.html')
          .then(response => response.text())
          .then(html => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const biasElements = doc.querySelectorAll('.bias');
            italianBiasData = {};
            
            biasElements.forEach(biasElement => {
              const title = biasElement.querySelector('h2').textContent.trim();
              const content = biasElement.querySelector('.content').innerHTML;
              const wikipediaLink = biasElement.querySelector('a').href;
              italianBiasData[title.toLowerCase()] = {
                content: content,
                wikipediaLink: wikipediaLink
              };
            });
          })
          .catch(error => {
            console.error('Error loading Italian bias data:', error);
          });

        // Clean up function to ensure proper state reset
        function cleanupPreviousTooltip() {
          if (hideTimeoutId) {
            clearTimeout(hideTimeoutId);
            hideTimeoutId = null;
          }

          if (currentElement && currentElement !== this) {
            currentElement.classList.remove('highlighted');
          }

          if (currentPopperInstance) {
            currentPopperInstance.destroy();
            currentPopperInstance = null;
          }
        }

        biasElements.forEach((element) => {
          // Get the bias name
          let biasName = '';
          const textElements = element.querySelectorAll('text');
          for (const textElement of textElements) {
            biasName = textElement.textContent.trim();
            if (biasName) break;
          }

          if (!biasName) return;

          const wikipediaUrl = element.getAttribute('xlink:href');

          // Get bias content from Italian data or use fallback
          const getBiasContent = () => {
            if (italianBiasData && italianBiasData[biasName.toLowerCase()]) {
              const biasInfo = italianBiasData[biasName.toLowerCase()];
              return `
                <div class="bias-content">
                  ${biasInfo.content}
                  <div class="wiki-link-container">
                    <a href="${biasInfo.wikipediaLink}" target="_blank" class="wiki-link">Leggi di più su Wikipedia</a>
                  </div>
                </div>
              `;
            } else {
              // Fallback to simple description
              return `
                <p>${getItalianBiasDescription(biasName)}</p>
                <div class="wiki-link-container">
                  <a href="${wikipediaUrl}" target="_blank" class="wiki-link">Leggi di più su Wikipedia</a>
                </div>
              `;
            }
          };

          const gElement = element.querySelector('g');
          (gElement || element).addEventListener('mouseenter', function () {
            // Clean up any previous tooltip state
            cleanupPreviousTooltip();

            // Highlight the current element
            element.classList.add('highlighted');
            currentElement = element;

            // Update tooltip content
            tooltip.innerHTML = `
              <div class="tooltip-arrow" data-popper-arrow></div>
              <div class="tooltip-content">
                <h3>${biasName}</h3>
                ${getBiasContent()}
              </div>
            `;

            // Show the tooltip
            tooltip.style.display = 'block';

            // Create new popper instance
            currentPopperInstance = Popper.createPopper(element, tooltip, {
              placement: 'auto',
              modifiers: [
                {
                  name: 'offset',
                  options: { offset: [0, 40] },
                },
                {
                  name: 'preventOverflow',
                  options: {
                    boundary: document.querySelector('#svg-container'),
                  },
                },
              ],
            });
          });

          element.addEventListener('mouseleave', function () {
            // Don't hide if tooltip is locked
            if (isTooltipLocked) return;

            // Set a timeout to hide the tooltip
            hideTimeoutId = setTimeout(() => {
              // Only hide if tooltip is not being hovered
              if (!tooltip.matches(':hover')) {
                tooltip.style.display = 'none';
                element.classList.remove('highlighted');
                currentElement = null;

                if (currentPopperInstance) {
                  currentPopperInstance.destroy();
                  currentPopperInstance = null;
                }
              }
            }, 50);
          });
        });

        // Handle mouse entering the tooltip itself
        tooltip.addEventListener('mouseenter', function () {
          // Lock the tooltip while hovering over it
          isTooltipLocked = true;

          // Clear any pending hide timeout
          if (hideTimeoutId) {
            clearTimeout(hideTimeoutId);
            hideTimeoutId = null;
          }
        });

        // Handle mouse leaving the tooltip
        tooltip.addEventListener('mouseleave', function () {
          // Unlock the tooltip
          isTooltipLocked = false;

          // Hide the tooltip after a short delay
          hideTimeoutId = setTimeout(() => {
            tooltip.style.display = 'none';

            if (currentElement) {
              currentElement.classList.remove('highlighted');
              currentElement = null;
            }

            if (currentPopperInstance) {
              currentPopperInstance.destroy();
              currentPopperInstance = null;
            }
          }, 50);
        });
      }

      // Helper function to get Italian descriptions for biases (fallback)
      function getItalianBiasDescription(biasName) {
        // Simple Italian descriptions for common biases
        const biasDescriptions = {
          'confirmation-bias': 'Tendenza a cercare, interpretare e ricordare informazioni che confermano le proprie convinzioni.',
          'anchoring': 'Tendenza a fare troppo affidamento sulla prima informazione ricevuta.',
          'availability-heuristic': 'Tendenza a stimare la probabilità di un evento in base alla facilità con cui esempi vengono in mente.',
          'dunning-kruger-effect': 'Tendenza delle persone incompetenti a sopravvalutare le proprie capacità.',
          'hindsight-bias': 'Tendenza a vedere eventi passati come più prevedibili di quanto non fossero in realtà.',
          'negativity-bias': 'Tendenza a dare più peso alle esperienze negative rispetto a quelle positive.',
          'optimism-bias': 'Tendenza a sopravvalutare la probabilità di eventi positivi e sottovalutare quella di eventi negativi.',
          'self-serving-bias': 'Tendenza ad attribuire i successi a fattori interni e i fallimenti a fattori esterni.',
          'status-quo-bias': 'Tendenza a preferire che le cose rimangano come sono.',
          'sunk-cost-fallacy': 'Tendenza a continuare un comportamento a causa di investimenti precedenti, anche quando non è razionale.'
        };

        // Try to find a matching description
        const simpleName = biasName.toLowerCase().replace(/\s+/g, '-');
        for (const key in biasDescriptions) {
          if (simpleName.includes(key) || key.includes(simpleName)) {
            return biasDescriptions[key];
          }
        }

        // Fallback description
        return `Un bias cognitivo che influenza il pensiero e il processo decisionale.`;
      }
    </script>
  </body>
</html>